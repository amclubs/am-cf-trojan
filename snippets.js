let id = 'ec872d8f-72b0-4a04-b612-0327d85e18ed';
let pnum = atob('NDQz'); let paddrs = [atob('cHJveHlpcC5hbWNsdWJzLmNhbWR2ci5vcmc='), atob('cHJveHlpcC5hbWNsdWJzLmtvem93LmNvbQ==')]; let paddr = paddrs[Math.floor(Math.random() * paddrs.length)]; let pDomain = []; let p64 = true; let p64DnUrl = atob('aHR0cHM6Ly8xLjEuMS4xL2Rucy1xdWVyeQ=='); let p64Prefix = atob('MjYwMjpmYzU5OmIwOjY0Ojo='); let p64Domain = []; let s5 = ''; let s5Enable = false; let parsedS5 = {}; let durl = atob('aHR0cHM6Ly9za3kucmV0aGlua2Rucy5jb20vMTotUGZfX19fXzlfOEFfQU1BSWdFOGtNQUJWRERtS09IVEFLZz0='); let fname = atob('5pWw5a2X5aWX5Yip'); let ytName = atob('aHR0cHM6Ly95b3V0dWJlLmNvbS9AYW1fY2x1YnM/c3ViX2NvbmZpcm1hdGlvbj0x'); let tgName = atob('aHR0cHM6Ly90Lm1lL2FtX2NsdWJz'); let ghName = atob('aHR0cHM6Ly9naXRodWIuY29tL2FtY2x1YnMvYW0tY2YtdHVubmVs'); let bName = atob('aHR0cHM6Ly9hbWNsdWJzcy5jb20='); let pName = '5pWw5a2X5aWX5Yip';
import { connect } from 'cloudflare:sockets';
if (!isValidUserId(id)) { throw new Error('err'); }
export default { async fetch(request, env) { try { const url = new URL(request.url); paddr = url.searchParams.get('PADDR') || paddr; if (paddr) { const [ip, port] = paddr.split(':'); paddr = ip; pnum = port || pnum } p64 = url.searchParams.get('P64') || p64; p64Prefix = url.searchParams.get('P64PREFIX') || p64Prefix; s5 = url.searchParams.get('S5') || s5; parsedS5 = await rps5FromUrl(s5, url); if (parsedS5) { s5Enable = true } durl = url.searchParams.get('D_URL') || durl; if (request.headers.get('Upgrade') === 'websocket') { return await websvcExecutorTr(request) } switch (url.pathname.toLowerCase()) { case '/': { return await login(request, env) } default: { return Response.redirect(new URL('/', request.url)) } } } catch (err) { return new Response(`Error:${err.message}`, { status: 500 }) } }, };
/***/
function isValidUserId(u) { const r = /^[0-9a-f]{8}-[0-9a-f]{4}-[4][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i; return r.test(u) }
const b = []; for (let i = 0; i < 256; ++i) { b.push((i + 256).toString(16).slice(1)) }
function usf(arr, offset = 0) { return (b[arr[offset + 0]] + b[arr[offset + 1]] + b[arr[offset + 2]] + b[arr[offset + 3]] + "-" + b[arr[offset + 4]] + b[arr[offset + 5]] + "-" + b[arr[offset + 6]] + b[arr[offset + 7]] + "-" + b[arr[offset + 8]] + b[arr[offset + 9]] + "-" + b[arr[offset + 10]] + b[arr[offset + 11]] + b[arr[offset + 12]] + b[arr[offset + 13]] + b[arr[offset + 14]] + b[arr[offset + 15]]).toLowerCase() }
function stringify(arr, offset = 0) { const u = usf(arr, offset); if (!isValidUserId(u)) { throw TypeError("err"); } return u }
function b64ToBuf(b) { if (!b) { return { earlyData: null, error: null } } try { b = b.replace(/-/g, '+').replace(/_/g, '/'); const d = atob(b); const a = Uint8Array.from(d, (c) => c.charCodeAt(0)); return { earlyData: a.buffer, error: null } } catch (error) { return { earlyData: null, error } } }
function deb64Utf8(s) { const b = Uint8Array.from(atob(s), c => c.charCodeAt(0)); return new TextDecoder('utf-8').decode(b) }
function rps5(s5) { let [latter, former] = s5.split("@").reverse(); let username, password, hostname, port; if (former) { const f = former.split(":"); if (f.length !== 2) { throw new Error('err'); } [username, password] = f } const l = latter.split(":"); port = Number(l.pop()); if (isNaN(port)) { throw new Error('err'); } hostname = l.join(":"); const i = hostname.includes(":") && !/^\[.*\]$/.test(hostname); if (i) { throw new Error('err'); } return { username, password, hostname, port } }
async function rps5FromUrl(s5, url) { if (/\/s5?=/.test(url.pathname)) { s5 = url.pathname.split('5=')[1] } else if (/\/socks[5]?:\/\//.test(url.pathname)) { s5 = url.pathname.split('://')[1].split('#')[0] } const a = s5.indexOf('@'); if (a !== -1) { let u = s5.substring(0, a); const r = /^(?:[A-Z0-9+/]{4})*(?:[A-Z0-9+/]{2}==|[A-Z0-9+/]{3}=)?$/i; if (r.test(u) && !u.includes(':')) { u = atob(u) } s5 = `${u}@${s5.substring(a + 1)}` } if (s5) { try { return rps5(s5) } catch (err) { return null } } return null }
async function gdTox(a, p, e, f = false) { let finalTargetHost = a; let finalTargetPort = p; try { const safeMatch = (domains, target) => { try { return Array.isArray(domains) && domains.some(domain => mdp(target, domain)) } catch (e) { return false } }; const d = safeMatch(pDomain, a); const d64 = safeMatch(p64Domain, a); if (e) { } else if (d) { finalTargetHost = paddr; finalTargetPort = pnum || p } else if (d64 || (f && p64)) { try { finalTargetHost = await rdTox(a); finalTargetPort = p } catch (err) { finalTargetHost = paddr || a; finalTargetPort = pnum || p } } else if (f) { finalTargetHost = paddr || a; finalTargetPort = p } return { finalTargetHost, finalTargetPort } } catch (err) { if (f) { finalTargetHost = paddr || a; finalTargetPort = p } return { finalTargetHost, finalTargetPort } } }
function mdp(h, p) { if (!h || !p) return false; h = h.toLowerCase(); p = p.toLowerCase(); const r4 = /^(\d{1,3}\.){3}\d{1,3}$/; const r6 = /^\[?([a-f0-9:]+)\]?$/i; if (r4.test(h) || r6.test(h)) { return false } const hp = h.split('.'); const pp = p.split('.'); if (hp.length < pParts.length) return false; for (let i = 1; i <= pParts.length; i++) { if (hp[hp.length - i] !== pp[pp.length - i]) { return false } } return true }
async function rdTox(d) { try { const r = await fetch(`${p64DnUrl}?name=${d}&type=A`, { headers: { Accept: "application/dns-json", }, }); if (!r.ok) { throw new Error(`err`) } const rs = await r.json(); const ar = rs?.Answer?.find(record => record.type === 1 && record.data); if (!ar) { throw new Error("err"); } const ipv4 = ar.data; const ipv6 = cTox(ipv4); return ipv6 } catch (err) { throw new Error(`err`) } }
function cTox(i4) { const p = i4.trim().split('.'); if (p.length !== 4) { throw new Error('err'); } const h = p.map(part => { const n = Number(part); if (!/^\d+$/.test(part) || isNaN(n) || n < 0 || n > 255) { throw new Error(`err`) } return n.toString(16).padStart(2, '0') }); let w = true; if (!p64Prefix || typeof p64Prefix !== 'string' || !p64Prefix.includes('::')) { throw new Error('err') } const i6 = `${h[0]}${h[1]}:${h[2]}${h[3]}`.toLowerCase(); const fi6 = `${p64Prefix}${i6}`; return w ? `[${fi6}]` : fi6 }
function stringToArray(str) { if (!str) return []; return str.split(/[\n,]+/).map(s => s.trim()).filter(Boolean) }
(function () {
    'use strict'; var ERROR = 'err'; var WINDOW = typeof window === 'object'; var root = WINDOW ? window : {}; if (root.JS_SHA256_NO_WINDOW) { WINDOW = false }; var WEB_WORKER = !WINDOW && typeof self === 'object'; var NODE_JS = !root.JS_SHA256_NO_NODE_JS && typeof process === 'object' && process.versions && process.versions.node; if (NODE_JS) { root = global } else if (WEB_WORKER) { root = self }; var COMMON_JS = !root.JS_SHA256_NO_COMMON_JS && typeof module === 'object' && module.exports; var AMD = typeof define === 'function' && define.amd; var ARRAY_BUFFER = !root.JS_SHA256_NO_ARRAY_BUFFER && typeof ArrayBuffer !== 'undefined'; var HEX_CHARS = '0123456789abcdef'.split(''); var EXTRA = [-2147483648, 8388608, 32768, 128]; var SHIFT = [24, 16, 8, 0]; var K = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5, 0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174, 0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da, 0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967, 0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85, 0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070, 0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3, 0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2]; var OUTPUT_TYPES = ['hex', 'array', 'digest', 'arrayBuffer']; var blocks = [];
    if (root.JS_SHA256_NO_NODE_JS || !Array.isArray) { Array.isArray = function (obj) { return Object.prototype.toString.call(obj) === '[object Array]' } }; if (ARRAY_BUFFER && (root.JS_SHA256_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView)) { ArrayBuffer.isView = function (obj) { return typeof obj === 'object' && obj.buffer && obj.buffer.constructor === ArrayBuffer } }; var createOutputMethod = function (outputType, is224) { return function (message) { return new Sha256(is224, true).update(message)[outputType]() } }; var createMethod = function (is224) { var method = createOutputMethod('hex', is224); if (NODE_JS) { method = nodeWrap(method, is224) } method.create = function () { return new Sha256(is224) }; method.update = function (message) { return method.create().update(message) }; for (var i = 0; i < OUTPUT_TYPES.length; ++i) { var type = OUTPUT_TYPES[i]; method[type] = createOutputMethod(type, is224) } return method }; var nodeWrap = function (method, is224) { var crypto = require('node:crypto'); var Buffer = require('node:buffer').Buffer; var algorithm = is224 ? 'sha224' : 'sha256'; var bufferFrom; if (Buffer.from && !root.JS_SHA256_NO_BUFFER_FROM) { bufferFrom = Buffer.from } else { bufferFrom = function (message) { return new Buffer(message) } } var nodeMethod = function (message) { if (typeof message === 'string') { return crypto.createHash(algorithm).update(message, 'utf8').digest('hex') } else { if (message === null || message === undefined) { throw new Error(ERROR); } else if (message.constructor === ArrayBuffer) { message = new Uint8Array(message) } } if (Array.isArray(message) || ArrayBuffer.isView(message) || message.constructor === Buffer) { return crypto.createHash(algorithm).update(bufferFrom(message)).digest('hex') } else { return method(message) } }; return nodeMethod }; var createHmacOutputMethod = function (outputType, is224) { return function (key, message) { return new HmacSha256(key, is224, true).update(message)[outputType]() } };
    var createHmacMethod = function (is224) { var method = createHmacOutputMethod('hex', is224); method.create = function (key) { return new HmacSha256(key, is224) }; method.update = function (key, message) { return method.create(key).update(message) }; for (var i = 0; i < OUTPUT_TYPES.length; ++i) { var type = OUTPUT_TYPES[i]; method[type] = createHmacOutputMethod(type, is224) } return method };
    function Sha256(is224, sharedMemory) { if (sharedMemory) { blocks[0] = blocks[16] = blocks[1] = blocks[2] = blocks[3] = blocks[4] = blocks[5] = blocks[6] = blocks[7] = blocks[8] = blocks[9] = blocks[10] = blocks[11] = blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0; this.blocks = blocks } else { this.blocks = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] } if (is224) { this.h0 = 0xc1059ed8; this.h1 = 0x367cd507; this.h2 = 0x3070dd17; this.h3 = 0xf70e5939; this.h4 = 0xffc00b31; this.h5 = 0x68581511; this.h6 = 0x64f98fa7; this.h7 = 0xbefa4fa4 } else { this.h0 = 0x6a09e667; this.h1 = 0xbb67ae85; this.h2 = 0x3c6ef372; this.h3 = 0xa54ff53a; this.h4 = 0x510e527f; this.h5 = 0x9b05688c; this.h6 = 0x1f83d9ab; this.h7 = 0x5be0cd19 } this.block = this.start = this.bytes = this.hBytes = 0; this.finalized = this.hashed = false; this.first = true; this.is224 = is224 };
    Sha256.prototype.update = function (message) { if (this.finalized) { return } var notString, type = typeof message; if (type !== 'string') { if (type === 'object') { if (message === null) { throw new Error(ERROR); } else if (ARRAY_BUFFER && message.constructor === ArrayBuffer) { message = new Uint8Array(message) } else if (!Array.isArray(message)) { if (!ARRAY_BUFFER || !ArrayBuffer.isView(message)) { throw new Error(ERROR); } } } else { throw new Error(ERROR); } notString = true } var code, index = 0, i, length = message.length, blocks = this.blocks; while (index < length) { if (this.hashed) { this.hashed = false; blocks[0] = this.block; this.block = blocks[16] = blocks[1] = blocks[2] = blocks[3] = blocks[4] = blocks[5] = blocks[6] = blocks[7] = blocks[8] = blocks[9] = blocks[10] = blocks[11] = blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0 } if (notString) { for (i = this.start; index < length && i < 64; ++index) { blocks[i >>> 2] |= message[index] << SHIFT[i++ & 3] } } else { for (i = this.start; index < length && i < 64; ++index) { code = message.charCodeAt(index); if (code < 0x80) { blocks[i >>> 2] |= code << SHIFT[i++ & 3] } else if (code < 0x800) { blocks[i >>> 2] |= (0xc0 | (code >>> 6)) << SHIFT[i++ & 3]; blocks[i >>> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3] } else if (code < 0xd800 || code >= 0xe000) { blocks[i >>> 2] |= (0xe0 | (code >>> 12)) << SHIFT[i++ & 3]; blocks[i >>> 2] |= (0x80 | ((code >>> 6) & 0x3f)) << SHIFT[i++ & 3]; blocks[i >>> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3] } else { code = 0x10000 + (((code & 0x3ff) << 10) | (message.charCodeAt(++index) & 0x3ff)); blocks[i >>> 2] |= (0xf0 | (code >>> 18)) << SHIFT[i++ & 3]; blocks[i >>> 2] |= (0x80 | ((code >>> 12) & 0x3f)) << SHIFT[i++ & 3]; blocks[i >>> 2] |= (0x80 | ((code >>> 6) & 0x3f)) << SHIFT[i++ & 3]; blocks[i >>> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3] } } } this.lastByteIndex = i; this.bytes += i - this.start; if (i >= 64) { this.block = blocks[16]; this.start = i - 64; this.hash(); this.hashed = true } else { this.start = i } } if (this.bytes > 4294967295) { this.hBytes += this.bytes / 4294967296 << 0; this.bytes = this.bytes % 4294967296 } return this };
    Sha256.prototype.finalize = function () { if (this.finalized) { return } this.finalized = true; var blocks = this.blocks, i = this.lastByteIndex; blocks[16] = this.block; blocks[i >>> 2] |= EXTRA[i & 3]; this.block = blocks[16]; if (i >= 56) { if (!this.hashed) { this.hash() } blocks[0] = this.block; blocks[16] = blocks[1] = blocks[2] = blocks[3] = blocks[4] = blocks[5] = blocks[6] = blocks[7] = blocks[8] = blocks[9] = blocks[10] = blocks[11] = blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0 } blocks[14] = this.hBytes << 3 | this.bytes >>> 29; blocks[15] = this.bytes << 3; this.hash() };
    Sha256.prototype.hash = function () { var a = this.h0, b = this.h1, c = this.h2, d = this.h3, e = this.h4, f = this.h5, g = this.h6, h = this.h7, blocks = this.blocks, j, s0, s1, maj, t1, t2, ch, ab, da, cd, bc; for (j = 16; j < 64; ++j) { t1 = blocks[j - 15]; s0 = ((t1 >>> 7) | (t1 << 25)) ^ ((t1 >>> 18) | (t1 << 14)) ^ (t1 >>> 3); t1 = blocks[j - 2]; s1 = ((t1 >>> 17) | (t1 << 15)) ^ ((t1 >>> 19) | (t1 << 13)) ^ (t1 >>> 10); blocks[j] = blocks[j - 16] + s0 + blocks[j - 7] + s1 << 0 } bc = b & c; for (j = 0; j < 64; j += 4) { if (this.first) { if (this.is224) { ab = 300032; t1 = blocks[0] - 1413257819; h = t1 - 150054599 << 0; d = t1 + 24177077 << 0 } else { ab = 704751109; t1 = blocks[0] - 210244248; h = t1 - 1521486534 << 0; d = t1 + 143694565 << 0 } this.first = false } else { s0 = ((a >>> 2) | (a << 30)) ^ ((a >>> 13) | (a << 19)) ^ ((a >>> 22) | (a << 10)); s1 = ((e >>> 6) | (e << 26)) ^ ((e >>> 11) | (e << 21)) ^ ((e >>> 25) | (e << 7)); ab = a & b; maj = ab ^ (a & c) ^ bc; ch = (e & f) ^ (~e & g); t1 = h + s1 + ch + K[j] + blocks[j]; t2 = s0 + maj; h = d + t1 << 0; d = t1 + t2 << 0 } s0 = ((d >>> 2) | (d << 30)) ^ ((d >>> 13) | (d << 19)) ^ ((d >>> 22) | (d << 10)); s1 = ((h >>> 6) | (h << 26)) ^ ((h >>> 11) | (h << 21)) ^ ((h >>> 25) | (h << 7)); da = d & a; maj = da ^ (d & b) ^ ab; ch = (h & e) ^ (~h & f); t1 = g + s1 + ch + K[j + 1] + blocks[j + 1]; t2 = s0 + maj; g = c + t1 << 0; c = t1 + t2 << 0; s0 = ((c >>> 2) | (c << 30)) ^ ((c >>> 13) | (c << 19)) ^ ((c >>> 22) | (c << 10)); s1 = ((g >>> 6) | (g << 26)) ^ ((g >>> 11) | (g << 21)) ^ ((g >>> 25) | (g << 7)); cd = c & d; maj = cd ^ (c & a) ^ da; ch = (g & h) ^ (~g & e); t1 = f + s1 + ch + K[j + 2] + blocks[j + 2]; t2 = s0 + maj; f = b + t1 << 0; b = t1 + t2 << 0; s0 = ((b >>> 2) | (b << 30)) ^ ((b >>> 13) | (b << 19)) ^ ((b >>> 22) | (b << 10)); s1 = ((f >>> 6) | (f << 26)) ^ ((f >>> 11) | (f << 21)) ^ ((f >>> 25) | (f << 7)); bc = b & c; maj = bc ^ (b & d) ^ cd; ch = (f & g) ^ (~f & h); t1 = e + s1 + ch + K[j + 3] + blocks[j + 3]; t2 = s0 + maj; e = a + t1 << 0; a = t1 + t2 << 0; this.chromeBugWorkAround = true } this.h0 = this.h0 + a << 0; this.h1 = this.h1 + b << 0; this.h2 = this.h2 + c << 0; this.h3 = this.h3 + d << 0; this.h4 = this.h4 + e << 0; this.h5 = this.h5 + f << 0; this.h6 = this.h6 + g << 0; this.h7 = this.h7 + h << 0 };
    Sha256.prototype.hex = function () { this.finalize(); var h0 = this.h0, h1 = this.h1, h2 = this.h2, h3 = this.h3, h4 = this.h4, h5 = this.h5, h6 = this.h6, h7 = this.h7; var hex = HEX_CHARS[(h0 >>> 28) & 0x0F] + HEX_CHARS[(h0 >>> 24) & 0x0F] + HEX_CHARS[(h0 >>> 20) & 0x0F] + HEX_CHARS[(h0 >>> 16) & 0x0F] + HEX_CHARS[(h0 >>> 12) & 0x0F] + HEX_CHARS[(h0 >>> 8) & 0x0F] + HEX_CHARS[(h0 >>> 4) & 0x0F] + HEX_CHARS[h0 & 0x0F] + HEX_CHARS[(h1 >>> 28) & 0x0F] + HEX_CHARS[(h1 >>> 24) & 0x0F] + HEX_CHARS[(h1 >>> 20) & 0x0F] + HEX_CHARS[(h1 >>> 16) & 0x0F] + HEX_CHARS[(h1 >>> 12) & 0x0F] + HEX_CHARS[(h1 >>> 8) & 0x0F] + HEX_CHARS[(h1 >>> 4) & 0x0F] + HEX_CHARS[h1 & 0x0F] + HEX_CHARS[(h2 >>> 28) & 0x0F] + HEX_CHARS[(h2 >>> 24) & 0x0F] + HEX_CHARS[(h2 >>> 20) & 0x0F] + HEX_CHARS[(h2 >>> 16) & 0x0F] + HEX_CHARS[(h2 >>> 12) & 0x0F] + HEX_CHARS[(h2 >>> 8) & 0x0F] + HEX_CHARS[(h2 >>> 4) & 0x0F] + HEX_CHARS[h2 & 0x0F] + HEX_CHARS[(h3 >>> 28) & 0x0F] + HEX_CHARS[(h3 >>> 24) & 0x0F] + HEX_CHARS[(h3 >>> 20) & 0x0F] + HEX_CHARS[(h3 >>> 16) & 0x0F] + HEX_CHARS[(h3 >>> 12) & 0x0F] + HEX_CHARS[(h3 >>> 8) & 0x0F] + HEX_CHARS[(h3 >>> 4) & 0x0F] + HEX_CHARS[h3 & 0x0F] + HEX_CHARS[(h4 >>> 28) & 0x0F] + HEX_CHARS[(h4 >>> 24) & 0x0F] + HEX_CHARS[(h4 >>> 20) & 0x0F] + HEX_CHARS[(h4 >>> 16) & 0x0F] + HEX_CHARS[(h4 >>> 12) & 0x0F] + HEX_CHARS[(h4 >>> 8) & 0x0F] + HEX_CHARS[(h4 >>> 4) & 0x0F] + HEX_CHARS[h4 & 0x0F] + HEX_CHARS[(h5 >>> 28) & 0x0F] + HEX_CHARS[(h5 >>> 24) & 0x0F] + HEX_CHARS[(h5 >>> 20) & 0x0F] + HEX_CHARS[(h5 >>> 16) & 0x0F] + HEX_CHARS[(h5 >>> 12) & 0x0F] + HEX_CHARS[(h5 >>> 8) & 0x0F] + HEX_CHARS[(h5 >>> 4) & 0x0F] + HEX_CHARS[h5 & 0x0F] + HEX_CHARS[(h6 >>> 28) & 0x0F] + HEX_CHARS[(h6 >>> 24) & 0x0F] + HEX_CHARS[(h6 >>> 20) & 0x0F] + HEX_CHARS[(h6 >>> 16) & 0x0F] + HEX_CHARS[(h6 >>> 12) & 0x0F] + HEX_CHARS[(h6 >>> 8) & 0x0F] + HEX_CHARS[(h6 >>> 4) & 0x0F] + HEX_CHARS[h6 & 0x0F]; if (!this.is224) { hex += HEX_CHARS[(h7 >>> 28) & 0x0F] + HEX_CHARS[(h7 >>> 24) & 0x0F] + HEX_CHARS[(h7 >>> 20) & 0x0F] + HEX_CHARS[(h7 >>> 16) & 0x0F] + HEX_CHARS[(h7 >>> 12) & 0x0F] + HEX_CHARS[(h7 >>> 8) & 0x0F] + HEX_CHARS[(h7 >>> 4) & 0x0F] + HEX_CHARS[h7 & 0x0F] } return hex }; Sha256.prototype.toString = Sha256.prototype.hex;
    Sha256.prototype.digest = function () { this.finalize(); var h0 = this.h0, h1 = this.h1, h2 = this.h2, h3 = this.h3, h4 = this.h4, h5 = this.h5, h6 = this.h6, h7 = this.h7; var arr = [(h0 >>> 24) & 0xFF, (h0 >>> 16) & 0xFF, (h0 >>> 8) & 0xFF, h0 & 0xFF, (h1 >>> 24) & 0xFF, (h1 >>> 16) & 0xFF, (h1 >>> 8) & 0xFF, h1 & 0xFF, (h2 >>> 24) & 0xFF, (h2 >>> 16) & 0xFF, (h2 >>> 8) & 0xFF, h2 & 0xFF, (h3 >>> 24) & 0xFF, (h3 >>> 16) & 0xFF, (h3 >>> 8) & 0xFF, h3 & 0xFF, (h4 >>> 24) & 0xFF, (h4 >>> 16) & 0xFF, (h4 >>> 8) & 0xFF, h4 & 0xFF, (h5 >>> 24) & 0xFF, (h5 >>> 16) & 0xFF, (h5 >>> 8) & 0xFF, h5 & 0xFF, (h6 >>> 24) & 0xFF, (h6 >>> 16) & 0xFF, (h6 >>> 8) & 0xFF, h6 & 0xFF]; if (!this.is224) { arr.push((h7 >>> 24) & 0xFF, (h7 >>> 16) & 0xFF, (h7 >>> 8) & 0xFF, h7 & 0xFF) } return arr }; Sha256.prototype.array = Sha256.prototype.digest;
    Sha256.prototype.arrayBuffer = function () { this.finalize(); var buffer = new ArrayBuffer(this.is224 ? 28 : 32); var dataView = new DataView(buffer); dataView.setUint32(0, this.h0); dataView.setUint32(4, this.h1); dataView.setUint32(8, this.h2); dataView.setUint32(12, this.h3); dataView.setUint32(16, this.h4); dataView.setUint32(20, this.h5); dataView.setUint32(24, this.h6); if (!this.is224) { dataView.setUint32(28, this.h7) } return buffer };
    function HmacSha256(key, is224, sharedMemory) { var i, type = typeof key; if (type === 'string') { var bytes = [], length = key.length, index = 0, code; for (i = 0; i < length; ++i) { code = key.charCodeAt(i); if (code < 0x80) { bytes[index++] = code } else if (code < 0x800) { bytes[index++] = (0xc0 | (code >>> 6)); bytes[index++] = (0x80 | (code & 0x3f)) } else if (code < 0xd800 || code >= 0xe000) { bytes[index++] = (0xe0 | (code >>> 12)); bytes[index++] = (0x80 | ((code >>> 6) & 0x3f)); bytes[index++] = (0x80 | (code & 0x3f)) } else { code = 0x10000 + (((code & 0x3ff) << 10) | (key.charCodeAt(++i) & 0x3ff)); bytes[index++] = (0xf0 | (code >>> 18)); bytes[index++] = (0x80 | ((code >>> 12) & 0x3f)); bytes[index++] = (0x80 | ((code >>> 6) & 0x3f)); bytes[index++] = (0x80 | (code & 0x3f)) } } key = bytes } else { if (type === 'object') { if (key === null) { throw new Error(ERROR); } else if (ARRAY_BUFFER && key.constructor === ArrayBuffer) { key = new Uint8Array(key) } else if (!Array.isArray(key)) { if (!ARRAY_BUFFER || !ArrayBuffer.isView(key)) { throw new Error(ERROR); } } } else { throw new Error(ERROR); } } if (key.length > 64) { key = (new Sha256(is224, true)).update(key).array() } var oKeyPad = [], iKeyPad = []; for (i = 0; i < 64; ++i) { var b = key[i] || 0; oKeyPad[i] = 0x5c ^ b; iKeyPad[i] = 0x36 ^ b } Sha256.call(this, is224, sharedMemory); this.update(iKeyPad); this.oKeyPad = oKeyPad; this.inner = true; this.sharedMemory = sharedMemory };
    HmacSha256.prototype = new Sha256(); HmacSha256.prototype.finalize = function () { Sha256.prototype.finalize.call(this); if (this.inner) { this.inner = false; var innerHash = this.array(); Sha256.call(this, this.is224, this.sharedMemory); this.update(this.oKeyPad); this.update(innerHash); Sha256.prototype.finalize.call(this) } }; var exports = createMethod(); exports.sha256 = exports; exports.sha224 = createMethod(true); exports.sha256.hmac = createHmacMethod(); exports.sha224.hmac = createHmacMethod(true); if (COMMON_JS) { module.exports = exports } else { root.sha256 = exports.sha256; root.sha224 = exports.sha224; if (AMD) { define(function () { return exports }) } };
})();
/***/
const WS_READY_STATE_OPEN = 1; const WS_READY_STATE_CLOSING = 2;
async function websvcExecutorTr(r) { const w = new WebSocketPair(); const [client, webSocket] = Object.values(w); webSocket.accept(); let address = ""; const rsw = { value: null }; let udpStreamWrite = null; const log = (info, event = "") => { }; const earlyDataHeader = r.headers.get("sec-websocket-protocol") || ""; const readableWebSocketStream = websvcStream(webSocket, earlyDataHeader, log); const handleStreamData = async (chunk) => { if (udpStreamWrite) { return udpStreamWrite(chunk) } if (rsw.value) { const writer = rsw.value.writable.getWriter(); await writer.write(chunk); writer.releaseLock(); return } const { hasError, message, portRemote = 443, addressRemote = "", rawClientData, addressType } = await handleRequestHeaderTr(chunk, id); address = addressRemote; if (hasError) { throw new Error(message); } handleTPOut(rsw, addressRemote, portRemote, rawClientData, webSocket, null, log, addressType) }; readableWebSocketStream.pipeTo(new WritableStream({ write: handleStreamData, close: () => { }, abort: (reason) => { }, })).catch((err) => { }); return new Response(null, { status: 101, webSocket: client }) }
function websvcStream(p, e, log) { let rsc = false; const s = new ReadableStream({ start(controller) { p.addEventListener('message', (event) => { const message = event.data; controller.enqueue(message) }); p.addEventListener('close', () => { closeDataStream(p); controller.close() }); p.addEventListener('error', (err) => { controller.error(err) }); const { earlyData, error } = b64ToBuf(e); if (error) { controller.error(error) } else if (earlyData) { controller.enqueue(earlyData) } }, pull(controller) { }, cancel(reason) { rsc = true; closeDataStream(p) } }); return s }
async function handleTPOut(r, ar, pr, rcd, pipe, crh, log, at) { async function connectAndWrite(address, port, socks = false) { const t = socks ? await serviceCall(at, address, port, log) : connect({ hostname: address, port: port, servername: ar }); r.value = t; const w = t.writable.getWriter(); await w.write(rcd); w.releaseLock(); return t } async function retry() { const finalTargetHost = paddr || ar; const finalTargetPort = pnum || pr; const t = s5Enable ? await connectAndWrite(finalTargetHost, finalTargetPort, true) : await connectAndWrite(finalTargetHost, finalTargetPort); t.closed.catch(error => { }).finally(() => { closeDataStream(pipe) }); transferDataStream(t, pipe, crh, null, log) } async function nat64() { const finalTargetHost = await rdTox(ar); const finalTargetPort = pr; const t = s5Enable ? await connectAndWrite(finalTargetHost, finalTargetPort, true) : await connectAndWrite(finalTargetHost, finalTargetPort); t.closed.catch(error => { }).finally(() => { closeDataStream(pipe) }); transferDataStream(t, pipe, crh, null, log) } async function finalStep() { try { if (p64) { const ok = await tryOnce(nat64, 'nat64'); if (!ok) await tryOnce(retry, 'retry') } else { const ok = await tryOnce(retry, 'retry'); if (!ok) await tryOnce(nat64, 'nat64') } } catch (err) { } } async function tryOnce(fn, tag) { try { const ok = await fn(); return true } catch (err) { return false } } const { finalTargetHost, finalTargetPort } = await gdTox(ar, pr, s5Enable, false); const t = await connectAndWrite(finalTargetHost, finalTargetPort, s5Enable ? true : false); transferDataStream(t, pipe, crh, finalStep, log) }
async function transferDataStream(rs, pipe, crh, retry, log) { let rcc = 0; let chunks = []; let ch = crh; let hid = false; await rs.readable.pipeTo(new WritableStream({ start() { }, async write(chunk, controller) { hid = true; rcc++; if (pipe.readyState !== WS_READY_STATE_OPEN) { controller.error('close') } if (ch) { pipe.send(await new Blob([ch, chunk]).arrayBuffer()); ch = null } else { pipe.send(chunk) } }, close() { }, abort(reason) { }, })).catch((error) => { closeDataStream(pipe) }); if (hid === false && typeof retry === 'function') { retry() } }
async function serviceCall(it, ri, rp, log) { const { username, password, hostname, port } = parsedS5; const s = connect({ hostname, port }); const w = s.writable.getWriter(); const r = s.readable.getReader(); const e = new TextEncoder(); const sendSocksGreeting = async () => { const greeting = new Uint8Array([5, 2, 0, 2]); await w.write(greeting) }; const handleAuthResponse = async () => { const res = (await r.read()).value; if (res[1] === 0x02) { if (!username || !password) { throw new Error("required"); } const authRequest = new Uint8Array([1, username.length, ...e.encode(username), password.length, ...e.encode(password)]); await w.write(authRequest); const authResponse = (await r.read()).value; if (authResponse[0] !== 0x01 || authResponse[1] !== 0x00) { throw new Error("failed"); } } }; const sendSocksRequest = async () => { let DSTADDR; switch (it) { case 1: DSTADDR = new Uint8Array([1, ...ri.split('.').map(Number)]); break; case 2: DSTADDR = new Uint8Array([3, ri.length, ...e.encode(ri)]); break; case 3: DSTADDR = new Uint8Array([4, ...ri.split(':').flatMap(x => [parseInt(x.slice(0, 2), 16), parseInt(x.slice(2), 16)])]); break; default: throw new Error("Invalid address type"); }const socksRequest = new Uint8Array([5, 1, 0, ...DSTADDR, rp >> 8, rp & 0xff]); await w.write(socksRequest); const response = (await r.read()).value; if (response[1] !== 0x00) { throw new Error("err"); } }; try { await sendSocksGreeting(); await handleAuthResponse(); await sendSocksRequest() } catch (error) { return null } finally { w.releaseLock(); r.releaseLock() } return s }
async function handleRequestHeaderTr(b, id) { if (b.byteLength < 56) { return { hasError: true, message: "err" } } let ci = 56; if (new Uint8Array(b.slice(56, 57))[0] !== 0x0d || new Uint8Array(b.slice(57, 58))[0] !== 0x0a) { return { hasError: true, message: "err" } } const p = new TextDecoder().decode(b.slice(0, ci)); if (p !== sha256.sha224(id)) { return { hasError: true, message: "err" } } const s5b = b.slice(ci + 2); if (s5b.byteLength < 6) { return { hasError: true, message: "err" } } const view = new DataView(s5b); const cmd = view.getUint8(0); if (cmd !== 1) { return { hasError: true, message: "unsupported" } } const at = view.getUint8(1); let addressLength = 0; let addressIndex = 2; let address = ""; switch (at) { case 1: addressLength = 4; address = new Uint8Array(s5b.slice(addressIndex, addressIndex + addressLength)).join("."); break; case 3: addressLength = new Uint8Array(s5b.slice(addressIndex, addressIndex + 1))[0]; addressIndex += 1; address = new TextDecoder().decode(s5b.slice(addressIndex, addressIndex + addressLength)); break; case 4: addressLength = 16; const dataView = new DataView(s5b.slice(addressIndex, addressIndex + addressLength)); const ipv6 = []; for (let i = 0; i < 8; i++) { ipv6.push(dataView.getUint16(i * 2).toString(16)) } address = ipv6.join(":"); break; default: return { hasError: true, message: `err` } }if (!address) { return { hasError: true, message: `err` } } const pi = addressIndex + addressLength; const portBuffer = s5b.slice(pi, pi + 2); const portRemote = new DataView(portBuffer).getUint16(0); return { hasError: false, addressRemote: address, portRemote, rawClientData: s5b.slice(pi + 4), addressType: at } }
function closeDataStream(s) { try { if (s.readyState === WS_READY_STATE_OPEN || s.readyState === WS_READY_STATE_CLOSING) { s.close() } } catch (error) { } }
/***/
async function login(request) { const h = { "Content-Type": "text/html; charset=UTF-8" }; if (request.method === "POST") { const pwd = (await request.formData()).get("password"); return pwd === id ? successPage() : new Response(renderPage({ bt: pName, suffix: "-ÁôªÂΩïÂ§±Ë¥•", h: "‚ùåÁôªÂΩïÂ§±Ë¥•", bc: `<p>ÂØÜÁ†ÅÈîôËØØ„ÄÇ</p><p><a href="/">ËøîÂõûÁôªÂΩï</a></p>` }), { headers: h }) } return new Response(renderPage({ bt: pName, suffix: "-ÁôªÂΩï", h: "ÁôªÂΩïÈ°µÈù¢", bc: `<form method="POST"><input type="password" name="password" placeholder="ÂØÜÁ†Å" required/><button type="submit">ÁôªÂΩï</button></form>` }), { headers: h }) }
async function successPage() { return new Response(renderPage({ bt: pName, suffix: "-ËÆæÁΩÆ", h: "ÁôªÂΩïÊàêÂäü", bc: `<form><button type="submit" style="background:#e74c3c;">ÈÄÄÂá∫ÁôªÂΩï</button></form>` }), { headers: { "Content-Type": "text/html; charset=UTF-8" } }) }
function renderPage({ bt, suffix = "", h, bc }) { const title = deb64Utf8(bt) + suffix; return `<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><title>${title}</title><style>body{margin:0;height:100vh;display:flex;justify-content:center;align-items:center;font-family:Arial;background:linear-gradient(135deg,#5563de,#89f7fe)}.c{background:#fff;padding:25px;border-radius:12px;box-shadow:0 6px 18px rgba(0,0,0,.2);width:360px;text-align:center;animation:f .5s}h1{font-size:22px;margin-bottom:15px}input,button{width:100%;padding:10px;font-size:15px;margin-top:10px;border-radius:6px;border:1px solid #ccc}button{background:#4CAF50;color:#fff;border:none;cursor:pointer}button:hover{background:#45a049}.links{margin-top:12px;font-size:14px}.links a{display:inline-block;width:46%;margin:4px;padding:6px 0;background:#f1f3ff;color:#5563DE;text-decoration:none;border-radius:6px}.links a:hover{background:#e0e4ff}@keyframes f{from{opacity:0;transform:translateY(20px)}to{opacity:1;transform:translateY(0)}}</style></head><body><div class="c"><h1>${h}</h1>${bc}<div class="links"><a href="${ytName}" target="_blank">üé¨YouTube</a><a href="${tgName}" target="_blank">üí¨Telegram</a><a href="${ghName}" target="_blank">üìÇGitHub</a><a href="${bName}" target="_blank">üåêBlog</a></div></div></body></html>` }
